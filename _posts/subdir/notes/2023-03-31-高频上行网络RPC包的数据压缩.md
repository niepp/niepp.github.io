# 1. 前言
> 客户端的上行高频RPC同步包，往往会占用很大的网络数据带宽，这里给出一个针对非可靠高频上行RPC的网络带宽压缩方案。

# 2. 方案思路

高频的RPC同步包序列，很多时候，相邻同步包序列里的数据本身变化并不大，某些字段可能根本就没有变化，或者即使有些数值变化了，变化量相对也很小。与其每次都发送全量的数据，不如考虑在发送了全量数据后，后续只发送序列间的差量数据，然后在接收端还原出全量数据，这对高频的RPC来说，可以节省大量的带宽。

重点要考虑的有两个问题：

+ 如何从序列数据生成差量数据
+ 差量数据的高性能高比例压缩


# 3. 从序列数据生成差量数据
## 3.1 生成差量数据的基准的选取
- 方案一：将当前包与前一个发送的包进行比较，生成差量数据，那么除了第一个包需要发送全量数据外，后续都只发送差量数据，但这样一来，数据包就一环套一环地对前一个包形成了依赖，只要前面有丢包，后续都没法从差量数据恢复出全量数据。这个方案只适用于可靠RPC。


- 方案二：以接收端所收到的最后一个包为基础计算差量数据。这个需要增加一个包序号来进行确认。具体做法如下：

	1. 给同步包增加一个序号标识。
	2. DS通过Replication下发最后一次收到的同步包里的序号到客户端Owner，标识DS最后一次收到的同步包是哪个。
	3. 客户端需要将过去发送的若干个同步包缓存起来，根据步骤2收到的序号，查找到那个同步包，将当前要发送的同步包数据与其对比计算出差量，将差量数据压缩后，附带上两个序号：一个是当前要发送的同步包的序号，一个是此包发送的差量数据是依赖的哪个同步包计算的（若是全量包则用无效序号标识），然后发送即可。
	4. DS端需要将最近一段时间内接收到的同步包，恢复全量后缓存起来。
	5. DS端接收到同步包后，首先从中获取此同步包是否差量包，若是则根据依赖的序号，从步骤4的缓存队列里找到这个包，然后以这个包和差量数据恢复出此数据包，然后再加入缓存队列。

## 3.2 差量数据的生成和全量数据的恢复

> 浮点数值做减法
> 二进制数值做异或
> 
生成差量数据
> 浮点数值：差量数据 = 当前包 - 基准包
> 二进制数值：差量数据 = 当前包 (二进制异或) 基准包
恢复全量数据
> 浮点数值：差量数据 = 当前包 + 基准包
> 二进制数值：差量数据 = 当前包 (二进制异或) 基准包

# 3. 差量数据的压缩
差量数据中的浮点具有比较小的绝对值，非常有利于量化压缩，而差量数据中的二进制数据，因为是按位异或得来的，很可能具有很多的连续0，这非常适合于使用行程长度编码（RLE: run-length encoding）

## 3.1 浮点数量化

上行同步包里的浮点数，主要是表示位置、朝向、线速度、角速度等的一些数据，常以FVector、FRotator形式存在。
+ 浮点数的量化压缩效率

以FVector_NetQuantize10为例，量化需要的bit数取决于三个数据成员（x, y, z）中绝对值最大的那个数，这个数的取值范围决定了量化这个Vector所需要的bit数

| 数据范围                | 量化需要的bit数 |
| ----------------------- | --------------- |
| 0 ~ 0.150000            | 11              |
| ~ 0.350000              | 14              |
| ~ 0.750000              | 17              |
| ~ 1.550000              | 20              |
| ~ 3.150000              | 23              |
| ~ 6.349999              | 26              |
| ~ 12.749999             | 29              |
| ~ 25.549997             | 32              |
| ~ 51.149998             | 34              |
| ~ 102.349991            | 37              |
| ~ 204.749985            | 40              |
| ~ 409.549957            | 43              |
| ~ 819.149963            | 46              |
| ~ 1638.349854           | 49              |
| ~ 3276.749756           | 52              |
| ~ 6553.549316           | 55              |
| ~ 13107.149414          | 59              |
| ~ 26214.347656          | 62              |
| ~ 52428.746094          | 65              |
| ~ 104857.539063         | 68              |
| ~ 209715.140625         | 71              |
| ~ 419430.312500         | 74              |
| ~ 838860.687500         | 77              |
| 838860.750000 ~ FLT_MAX | 80              |

| 数据范围                  | 量化需要的bit数 |
| ------------------------ | --------------- |
| 0 ~ -0.150000            | 11              |
| ~  -0.350000             | 14              |
| ~  -0.750000             | 17              |
| ~  -1.550000             | 20              |
| ~  -3.150000             | 23              |
| ~  -6.350000             | 26              |
| ~  -12.750000            | 29              |
| ~  -25.549999            | 32              |
| ~  -51.150002            | 34              |
| ~  -102.349998           | 37              |
| ~  -204.750000           | 40              |
| ~  -409.549988           | 43              |
| ~  -819.150024           | 46              |
| ~  -1638.349976          | 49              |
| ~  -3276.750000          | 52              |
| ~  -6553.549805          | 55              |
| ~  -13107.150391         | 59              |
| ~  -26214.349609         | 62              |
| ~  -52428.750000         | 65              |
| ~  -104857.546875        | 68              |
| ~  -209715.156250        | 71              |
| ~  -419430.343750        | 74              |
| ~  -838860.750000        | 77              |
| -838860.812500 ~ FLT_MIN | 80              |


# 3. 差量压缩
## 3.1 浮点数值
> 浮点数值做减法
> 二进制数值做异或